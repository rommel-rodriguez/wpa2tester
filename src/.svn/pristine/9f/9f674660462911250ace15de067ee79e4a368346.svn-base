#include <allheads.h>
#include <pcap.h>
#include <glib.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <getopt.h>
#include <ctype.h>
#include "hacking.h"
#include "hacking-network.h" 

void pcap_fatal(const char *, const char *);
void decode_ethernet(const u_char *);
void decode_ip(const u_char *);
u_int decode_tcp(const u_char *);
void parse_arguments(int argc, char *argv[]);
char *get_monitor();
pcap_t *get_monitorable_device();

char *mon_pattern = ".*mon.*";

int main(int argc, char *argv[]){
    //printf("All arguments:\n%s\n", argv[1]);
    //parse_arguments(argc, argv);
    pcap_t *device_handle;
    if ((device_handle = get_monitorable_device()) != NULL){
        printf("Main: Found monitorable device \n"); 

    }else{
        exit(1); 
    }
}

void pcap_fatal(const char *failed_in, const char *errbuf){
    printf("Fatal Error in %s:%s\n", failed_in, errbuf);
    exit(1);
}

void parse_arguments(int argc, char *argv[]){
    printf("Testing Inside:\n%s\n", argv[3]);
    int c;
    opterr = 0;
    char cvalue[100];
    while ((c = getopt(argc, argv, "abc:")) != 1)
        switch (c){
            case 'a': fprintf(stdout, "Option Selected is %c\n", c);
                      break;
            case 'b': fprintf(stdout, "Option Selected is %c\n", optopt);
                      break;
            case 'c': strcpy(cvalue,  optarg);
                      printf("C has Value %s\n", cvalue);
                      break;
            case '?':
                if (optopt == 'c')
                    fprintf (stderr, "Option -%c requires an argument.\n", optopt);
                else if (isprint (optopt))
                        fprintf (stderr, "Unknown option `-%c'.\n", optopt);
                else
                        fprintf (stderr,
                                "Unknown option character `\\x%x'.\n",
                                optopt);
                        return ;
                        break;
            default:
                printf("No Option passed, Terminating the program\n");
                abort ();
                                    
        }
}

char *get_monitor(){
    GRegex *start_regex = g_regex_new(mon_pattern, 0, 0, NULL);
    pcap_if_t *alldevsp , *device;
 
    char errbuf[PCAP_ERRBUF_SIZE] , *devname , devs[100][100];
    char *first_device;
    int count = 1 , n;

    first_device = pcap_lookupdev(errbuf); // pcap_lookupdev returns a pointer to the first 
                                           // character of a string containing the name of the
                                           // first network interface found int the system.
    printf("First Device %s\n", first_device);
    //First get the list of available devices
    printf("Finding available devices ... ");

    if( pcap_findalldevs( &alldevsp , errbuf) )
    {
        printf("Error finding devices : %s" , errbuf);
        exit(1);
    }
    printf("Done");

    //Print the available devices
    printf("\nAvailable Devices are :\n");
    gint mstart=0, mend=0;
    for(device = alldevsp ; device != NULL ; device = device->next)
    {
        GMatchInfo *start_info;

        printf("%d. %s - %s\n" , count , device->name , device->description);

        g_regex_match(start_regex, (gchar *)device->name, 0, &start_info);
        g_match_info_fetch_pos(start_info, 0, &mstart, &mend);
        g_match_info_free(start_info);
        if(mend != 0){
            printf("=========>Found monitor: %s<===========\n",device->name); 
            return device->name;
        }
        if(device->name != NULL)
        {
            strcpy(devs[count] , device->name);
        }
        count++;
    }
    return NULL;
}

/** function get_monitorable_device
 * Needs to have root permission to work properly  and return 
 *  the right device, else it returns the first device it finds.
 *  */
pcap_t *get_monitorable_device(){
    pcap_t *pcap_handle;
    pcap_if_t *alldevsp , *device;
 
    char errbuf[PCAP_ERRBUF_SIZE] , *devname , devs[100][100];
    char *first_device;
    int count = 1, n;

    first_device = pcap_lookupdev(errbuf); // pcap_lookupdev returns a pointer to the first 
                                           // character of a string containing the name of the
                                           // first network interface found int the system.
    printf("First Device %s\n", first_device);
    //First get the list of available devices
    printf("Finding available devices ... ");

    if( pcap_findalldevs( &alldevsp , errbuf) )
    {
        printf("Error finding devices : %s" , errbuf);
        exit(1);
    }
    printf("Done");

    //Print the available devices
    printf("\nAvailable Devices are :\n");
    for(device = alldevsp ; device != NULL ; device = device->next)
    {

        printf("%d. %s - %s\n" , count , device->name , device->description);
        pcap_handle = pcap_create(device->name, errbuf); // Creates the device without activating it

        if(pcap_handle != NULL && pcap_can_set_rfmon(pcap_handle)){
            printf("=========>Found monitor capable interface: %s<===========\n",device->name); 
            return pcap_handle;
        }
        if(device->name != NULL)
        {
            strcpy(devs[count] , device->name);
        }
        count++;
    }
    return NULL;
}

void activate_monitor(pcap_t *device_handle){
    pcap_set_rfmon(device_handle, 1);
    pcap_set_snaplen(device_handle, 2048); /* Snapshot length */
    pcap_set_timeout(device_handle, 1000); /* Timeout in milliseconds */
    pcap_activate(device_handle);
    /* handle is ready for use with pcap_next() or pcap_loop() */
}
